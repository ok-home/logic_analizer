[En](/README.md)

| Supported Targets |  
| ESP32             | 
| ----------------- |

# Логический анализатор на ESP32 для самодиагностики

![WebSocket](/la_ws.jpg)
![PulseView](/sigrok_esp.jpg)

## Основные параметры
 - 16 каналов.
 - 40 мегагерц. - максимальная частота сэмплов
 - 50000 - максимальное количество сэмплов в кадре ( буфер захвата ). Объем ограничен максимальным размером свободной DRAM.
 - 1 канал триггера захвата. Триггер организован на прерываниях по фронтам. ESP32 прерывания обрабатываются примерно 2 мкСек - Соответственно задержка от триггера до начала данных, около 2-х мкСек. В последней версии триггер переведен на Hilevel прерывания ( level 5 ), Задержка от триггера до начала данных уменьшена до 0,3 мкСек.
 - Используется внутренний клок сэмплов, нет необходимости ставить перемычки для подачи синхроимпульсов или использовать внешний генератор. Пины под синхроимпульсы не используются.
 - Анализатор позволяет работать на измеряемом устройстве. Устанавливаем софт на пациента настраиваем GPIO на каналы ( проверено - GPIO, I2C, LED PWM, IRQ_GPIO думаю что остальное также будет работать ), показывает как входные так и выходные сигналы пациента. Ограничения по триггеру в этом режиме - нельзя назначить триггер на пин (GPIO) у которого назначено прерывание на софте пациента ( анализатор перенастроит на себя ) - в последней версии (interrupt level 5) ограничение частично снято, но триггер будет срабатывать по тем фронтам(уровням), которые назначены на софте пациента.
 - Можно сделать анализатор как отдельное устройство, но не вижу особого смысла На рынке достаточное количество дешевых аналогов с похожими харатеристиками. Основное преимущество самодиагностики - прилинковали софт к проекту и смотрим, что там происходит. Понятно что софт пациента может уже использовать всю DRAM - тогда сильно уменьшится объем сэмплов - но хотя бы уровни и небольшое количество отсчетов все равно увидим.
  ## Простой web интерфейс
  - Подключение совсем без проводов
  - Простая настройка GPIO на каналы
  - Просмотр сэмплов ( без анализатора протоколов )
  - Сохранение данных в .bin формате который потом можно при необходимости передать в тот же Sigrok PulseView ( 16 каналов )
  - Подключение к wifi - example_connect в menuconfig
 ## В качестве визуализации и анализатора протоколов можно использовать Sigrok PulseView 
  - Открытый софт
  - Много анализаторов протокола
  - при прямом (SUMP) подключении используется UART для получения данных, протокол передачи "Openbench logic Sniffer & SUMP"
  - по умолчанию используется UART0 ESP32 можно ( а лучше нужно ) использовать другой порт, если он есть на вашем устройстве. Можно настроить в menuconfig. 
  - можно использовать ( рекомендую ) сохраненные данные из web интерфейса rawBin
  - рекомендую использовать прямое подключение к SUMP/Sigrok PulseView только при дефиците ресурсов ( Rom/Ram ). SUMP протокол очень маленький по объему кода.
  ## Известные баги
  - при использовании SUMP/Sigrok UART0 - необходимо отключить весь дигностический вывод ESP32 (LOG LEVEL - NONE ), это не баг но существенное ограничение.
  - PulseView - для получения данных нужно нажать RUN 2 раза с интервалом 1-2 секунды ( причину не знаю )
  - PulseView - в режиме триггера не работает с кадрами меньше 1к ( причину не знаю )
  - PulseView - не принимает параметр максимальной частоты сэмплов - легко увидите частоты 50/100/200 мегаГерц.
  - PulseView - не работает предвыборка триггера ( ставим 0% ) - просто не делал, и в текущей архитектуре невозможно.
  - PulseView - невозможно поставить частоту выборки 40 mHz
  # Подключение PulseView
  - Connect to device
  - Choose the driver - Openbench logic Sniffer & SUMP
  - Serial Port - Speed - 921600 ( скорость можно переопределить, на моем кабеле работает на этой скорости )
  - Scan for Device - должен появиться ESP32 with 16 channels
  - Дальше читаем руководство по PulseView.
  - Для чтения .bin файлов - просто импорт rawBin, 16 каналов, нужная частота сэмплов.
  # Подключение Web интерфейса ----- заходим на страничку по адресу http://xxxxxxx/la
  # Интерфейс программы
  ## Условно состоит из 3-х частей
  ### include/logic_analyzer_hal.h
  - Получает сэмплы в буфер ESP32
  - logic_analyzer_config_t - конфигурация захвата
  - start_logic_analyzer(logic_analyzer_config_t *config) - старт захвата
  - void (*logic_analyzer_cb_t)(uint16_t *samle_buf, int samples, int sample_rate) - каллбэк после захвата данных
  ### include/logic_analyzer_sump.h
  - работа с PulseView 
  - logic_analyzer_sump(); 
  ### include/logic_analyzer_ws_server.h
  - Стартуем web сервер с поддержкой websocket
  - logic_analyzer_ws_server()
  ### include/logic_analyzer_ws.h
  - если на вашем устройстве уже установлен сервер с поддержкой websocket - просто зарегистрируйте uri handler
  - logic_analyzer_register_uri_handlers(httpd_handle_t server);
  ## Пример с тестовыми сэмплами
  ### logic_analyzer_example
  - test_sample_init() - включает простой генератор на 100 килогерц, пачку GPIO имульсов с большой скважностью и пачку GPIO импульсов сформированных по прерываниям. Никаких дополнительных подключений, проводков и пр. не нужно, уже будет показывать внутренности. При желании можете поставить 2 перемычки на пины (18-22,19-23) - продублирует сигналы на GPIO.
  - вишенка на торте - подключаемся любым каналом на GPIO1 (TXD0) и смотрим свой же uart0 (только web)
  ## В основном для SUMP/Sigrok -  настройки вынесены в menuconfig
  ## Для использования Hi-level interrupt необходимо в menuconfig поставить CONFIG_ESP_SYSTEM_CHECK_INT_LEVEL = ESP_SYSTEM_CHECK_INT_LEVEL_4

## В проекте использованы части кода
 - [esp32-cam](https://github.com/espressif/esp32-camera) for I2S DMA
 - [EUA/ESP32_LogicAnalyzer](https://github.com/EUA/ESP32_LogicAnalyzer) for SUMP

### Проект делался под себя поэтому пожелания добавления и исправления только при желании и возможности.